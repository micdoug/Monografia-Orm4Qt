Neste capítulo será descrito um trabalho correlato, que também propôs o desenvolvimento de uma biblioteca ORM para C++ e que é utilizado como base para o desenvolvimento deste trabalho. Também será descrita uma biblioteca ORM presente no mercado, que é bastante utilizada em conjunto com o framework Qt no desenvolvimento de aplicativos comerciais. Esta biblioteca será utilizada na realização de testes comparativos ao final do trabalho.

\section{Um framework de mapeamento objeto-relacional com um exemplo em C++}
\label{sec:zhangXiaobing}

Em seu trabalho intitulado "Um framework de mapeamento objeto-relacional com um exemplo em C++", \textit{Zhang Xiaobing} apresenta um modelo para desenvolvimento de uma biblioteca ORM que pode ser utilizado na maioria das linguagens orientadas a objetos. Em seu modelo, ele define padrões a serem utilizados para resolver problemas como mapeamento de classes simples, herança, composição, associação, e ainda define mecanismos de otimização como criação de um cache de objetos resgatados do banco de dados \cite{xiaobingZhang}.

Seu modelo define uma biblioteca ORM que segue o paradigma orientado a aplicação, onde o desenvolvedor ficará responsável por definir toda a parte do código relacionado a criação dos objetos a serem mapeados. Todo objeto a ser mapeado deve herdar de uma classe específica, e o desenvolvedor deve reimplementar determinados métodos de modo a informar para a biblioteca metadados que definem o mapeamento. Devido a esse comportamento dizemos que a biblioteca não é transparente. O modelo ainda define uma arquitetura de desenvolvimento em duas camadas:

\begin{description}
\item[1) Camada de objetos (\textit{\textbf{Object Layer}})]
Camada responsável por prover uma interface simples para definição de classes a serem mapeadas e seus metadados, além de trafegar dados entre os objetos mapeados e a camada de persistência. Esta camada é a única acessível diretamente pelo desenvolvedor.

\item[2) Camada de persistência (\textit{\textbf{Storage Layer}})]
Camada responsável por abstrair a comunicação com o SGBD, provendo rotinas de persistência, concorrência, recuperação de erros e execuções de pesquisas no banco de dados. Esta camada não é diretamente acessível pelo desenvolvedor.
\end{description}

O modelo definido pode ser aplicado em diversas linguagens pelo fato de não se aproveitar de recursos específicos de determinadas linguagens, porém devido a isso ele exige um trabalho adicional do desenvolvedor ao reimplementar métodos de diversas interfaces definidas. Em alguns momentos, o desenvolvedor deve explicitamente executar funções de consulta e ajuste de valores de atributos em suas classes trocando informações com o framework para permitir a execução de tarefas no banco de dados \cite{xiaobingZhang}. Isso ocorre devido a biblioteca não definir um mecanismo de listagem e acesso às estruturas internas dos objetos mapeados.

Neste trabalho o modelo de Zhang é utilizado como base para a implementação de uma biblioteca ORM para C++, porém com alguns ajustes como a definição de uma interface de anotações para definições de mapeamento, e a capacidade de mapeamento de classes arbitrárias, sem a necessidade de herança de uma classe específica (biblioteca transparente).

\section{QxORM}
\label{sec:qxorm}

A QxORM é uma biblioteca ORM de código aberto desenvolvida para ser utilizada em conjunto com o framework Qt. Ela utiliza vários módulos do framework para auxiliar as tarefas de mapeamento, como por exemplo o módulo QtSql para realizar interações com os SGBDs. É uma biblioteca que segue o paradigma orientado a aplicação, e é transparente, ou seja, permite o mapeamento de classes arbitrárias. Para mapear uma classe, o desenvolvedor deve inserir algumas marcações na definição da classe, e implementar um método utilizando funções específicas para registros de informações das classes e atributos a serem mapeados. Portanto, nesta biblioteca também não existe um sistema de anotações \cite{qxorm}.

Esta biblioteca será utilizada durante testes de usabilidade, onde será comparado a abordagem de especificação de mapeamento dela com a interface de anotações criada neste trabalho. Além de testes de usabilidade, também serão feitos testes de desempenho em relação ao uso de memória e tempo de resposta. 